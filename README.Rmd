---
title: "Step-by-Step Guidelines to Implement Hybrid Ethnoracial Prediction"
author: "Diana Da In Lee (dl2860@columbia.edu)"
date: "Last Updated: `r format(Sys.time(), '%d %B, %Y')`"
output: github_document
---

```{r setup, include=FALSE}
rm(list=ls())
library(tidyverse)
library(dplyr)
library(magrittr)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
knitr::opts_chunk$set(echo = TRUE)
options(warn = -1) 
```

This guideline walks through how to implement the proposed hybrid approach to ethnoracial prediction in Lee, Diana, and Yamil Velez. "[Measuring descriptive representation at scale: Methods for predicting the race and ethnicity of public officials.](https://osf.io/tpsv6/)" (2023+).

We will use the US local elections dataset compiled by [de-Benedictis Kessner et al (2023)](https://dash.harvard.edu/handle/1/37373139). We've sampled 100 elections from the main dataset with 30\% of the names with verified ethnoracial information: 

```{r echo = F}
load('data/demo.rdata')
head(demo)
```

## 1. Image-Based Prediction

We first want to collect images associated with each name and make predictions based on the images. We provide two python functions `img_search` and `img_pred` to do these steps. For users who don't have python installed in their computer, we also provide a Google Colab demonstration here: [PredEthnorace_Demo.ipynb](https://github.com/DianaDaInLee/PredEthnorace/blob/main/PredEthnorace_Demo.ipynb).  

### 1.1. Collect Images

Collect profile images of the individuals in the dataset, using their first and last names as a keyword. Users may use any public engine. We provide a python function `img_search` (in `img_pred.py`) that allows for users to collect images from [DuckDuckGo](https://duckduckgo.com). The function automatically 1) removes images with no faces; 2) removes images with multiple faces; and 3) de-dupes identical faces (remove one of the images that are detected to be of a same person as the one in another image).

The `img_search` function in takes the following arguments:

* `fullname` (string): First and last name to be used as a keyword for image search.
* `maxnum` (integer): Total number of images you want to collect per keyword.
* `imgfolder` (string): Name of the folder you want the images to be saved. It will automatically create the folder in your working directory.

Each image will be saved in jpg as [`keyword`]_[0 through `maxnum`].jpg. All images associated with each keyword will be stored in its own folder named after the keyword (so make sure to dedup the full names in your dataset!). 

```{python, eval = F}
img_search(fullname = 'diana lee', maxnum = 3, imgfolder = 'demo')
glob.glob('demo/*/*')
```
````{python, eval = F}
['demo/diana_lee/diana_lee_0.jpg',
 'demo/diana_lee/diana_lee_1.jpg',
 'demo/diana_lee/diana_lee_2.jpg']
````

Using the demo dataset,
```{python, eval = F}
# Python
import pyreadr
df = pyreadr.read_r('demo.rdata') 
demo = df["demo"]

# Collect Images
for index, row in demo.iterrows():
    print(row['fullname'])
    img_search(fullname = row['fullname'], maxnum = 3, imgfolder = 'demo')
```

### 1.2. Generate Predictions

#### 1.2.1 Use CNN Model

We provide a python function `img_pred` (in `img_pred.py`) that allows for users to predict ethnorace for each image using `deepface` developed by [Sefik Serengil](https://github.com/serengil/deepface) that uses a pre-trained CNN model [VGG-Face](https://sefiks.com/2018/08/06/deep-face-recognition-with-keras/) to predict ethnorace from an image. This package is available in python and is fairly straightforward to use. 

The `img_pred` function takes the following arguments:

* `imgfolder` (string): Name of the folder where the images are saved. Should be the same as the folder name used in `img_search`.
* `subfolder` (string): Name of a particular subfolder (i.e., keyword) under `imgfolder` that you want predictions to be performed. Default is NULL, which will generate predictions for all images in all subfolders saved in `imgfolder`.
* `det` (string): face detector backend to opencv (default), retinaface, mtcnn, ssd, dlib, mediapipe or yolov8. See [https://github.com/serengil/deepface](https://github.com/serengil/deepface) for differences across different detectors.
* `out_csv` (boolean): Save the result as a csv file to a `imgfolder`. Default is TRUE.

```{python, eval = F}
pred = img_pred(imgfolder = 'demo', det = "opencv", out_csv = True)
```
```{r, echo = F}
pred <- read.csv('demo/img_pred.csv')
head(pred)
```

Not that there are many many different CNN models available. Our function is merely a demonstration using one of these models.

#### 1.2.2 Aggregate Generated Predictions

Note that the predictions are made for *each* image. To get a single vector of predicted probability distribution for a given name, you can take a simple average or weighted average by the order in which the images appear in the search engine (these are identifiable by the file name). In our validation, we find that up-weighting images that appear first results in a slightly higher accuracy. 

```{r}
pred_agg <- pred %>%
  separate(fn, c('imgfolder', 'keyword', 'filename'), sep = '/') %>%
  mutate(order = abs(as.numeric(stringr::str_extract(filename, '[0-9]+')) - 3)) %>%
  group_by(keyword) %>%
  summarize(across(asian:latino.hispanic, ~weighted.mean(.x, w = order)))
head(pred_agg)

# Merge it with Raw Data
pred_agg <- rename_at(pred_agg, vars(asian:latino.hispanic), ~ paste0('image.', .x))
demo1 <- left_join(demo %>% mutate(keyword = tolower(gsub(" ", "_", fullname))), pred_agg)
```

## 2. Surname-Based Prediction

This part is very simple. Use `wru` package created by [Imai and Khanna (2016)](https://imai.fas.harvard.edu/research/race.html) to generate surname-based predictions:

```{r, message = FALSE, comment = FALSE, warning = FALSE}
library(wru)
demo2 <- predict_race(voter.file = demo1, surname.only = T)
demo2 <- demo2 %>% rename_at(vars(matches('^pred\\.')), ~ gsub('pred', 'bayes', .x))
```

## 3. Run multinomial logistic regression

```{r}
library(nnet)
cov <- names(demo2)[which(grepl('bayes|image', names(demo2)))]
eq  <- as.formula(paste('race ~ ', paste(cov, collapse = ' + ')))
print(eq)
mod <- multinom(eq, data = demo2)
demo2$pred_race = predict(mod, newdata = demo2, "class")
```

Users are free to employ fancier machine learning algorithms (but our validation finds that this simple multinomial model performs just as well).